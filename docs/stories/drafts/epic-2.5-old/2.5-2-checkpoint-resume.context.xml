<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2.5</epicId>
    <storyId>2</storyId>
    <title>Checkpoint &amp; Resume</title>
    <status>drafted</status>
    <generatedAt>2025-11-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/drafts/epic-2.5-old/story-2.5-2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer running long-running agent workflows</asA>
    <iWant>the ability to checkpoint execution state and resume from failures</iWant>
    <soThat>workflows can recover gracefully from crashes without losing progress</soThat>
    <tasks>
      <!-- Phase 1: Checkpoint Infrastructure (1-1.5h) -->
      <task id="1" phase="1">
        <title>Create checkpoint schema in PGlite</title>
        <ac>1</ac>
        <subtasks>
          <subtask
          >Create migration src/db/migrations/006_workflow_checkpoints.sql with workflow_checkpoints table</subtask>
          <subtask>Add checkpoint queries to src/db/queries.ts</subtask>
        </subtasks>
      </task>
      <task id="2" phase="1">
        <title>Implement checkpoint save logic</title>
        <ac>2, 5</ac>
        <subtasks>
          <subtask>Create src/dag/checkpoint-manager.ts</subtask>
          <subtask>Implement saveCheckpoint(state, dag, layerIndex) method</subtask>
          <subtask>Generate unique checkpoint_id (UUID v4)</subtask>
          <subtask>Serialize state to JSON and save to PGlite with transaction</subtask>
          <subtask>Update state.checkpoint_id after save</subtask>
        </subtasks>
      </task>

      <!-- Phase 2: Resume Logic (1h) -->
      <task id="3" phase="2">
        <title>Implement resume from checkpoint</title>
        <ac>3, 6</ac>
        <subtasks>
          <subtask>Add resumeFromCheckpoint(checkpointId) method to ControlledExecutor</subtask>
          <subtask>Load checkpoint from PGlite and deserialize state, DAG, config</subtask>
          <subtask>Restore WorkflowState with reducers</subtask>
          <subtask>Calculate remaining layers and continue execution</subtask>
        </subtasks>
      </task>
      <task id="4" phase="2">
        <title>Integrate checkpoint saves in execution loop</title>
        <ac>2</ac>
        <subtasks>
          <subtask>Save checkpoint after each layer completion</subtask>
          <subtask>Emit checkpoint_saved event with checkpoint_id and timestamp</subtask>
          <subtask>Handle checkpoint save failures gracefully (log, continue)</subtask>
        </subtasks>
      </task>

      <!-- Phase 3: Pruning & Optimization (0.5-1h) -->
      <task id="5" phase="3">
        <title>Implement checkpoint pruning strategy</title>
        <ac>4</ac>
        <subtasks>
          <subtask>Keep only N most recent checkpoints per workflow (default: 5)</subtask>
          <subtask>Implement pruneOldCheckpoints(workflowId, keepCount) method</subtask>
          <subtask>Run pruning async (don't block execution)</subtask>
        </subtasks>
      </task>
      <task id="6" phase="3">
        <title>Optimize checkpoint size</title>
        <ac>9</ac>
        <subtasks>
          <subtask>Only store completed tasks (not pending/speculative)</subtask>
          <subtask>Compress large context values if needed</subtask>
          <subtask>Target &lt;100KB per checkpoint, log warning if &gt;500KB</subtask>
        </subtasks>
      </task>

      <!-- Phase 4: Testing & Validation (0.5h) -->
      <task id="7" phase="4">
        <title>Unit tests for checkpoint/resume</title>
        <ac>7</ac>
        <subtasks>
          <subtask>Test: Save checkpoint → Resume → State matches exactly</subtask>
          <subtask>Test: Multi-layer workflow → Resume continues from correct layer</subtask>
          <subtask>Test: Resume with modified DAG handles gracefully</subtask>
          <subtask>Test: Checkpoint pruning keeps only N recent</subtask>
          <subtask>Test: Failed checkpoint save doesn't crash execution</subtask>
        </subtasks>
      </task>
      <task id="8" phase="4">
        <title>Performance validation</title>
        <ac>8</ac>
        <subtasks>
          <subtask>Benchmark: Checkpoint save &lt;50ms (P95)</subtask>
          <subtask>Benchmark: Resume latency &lt;100ms</subtask>
          <subtask>Test with large state (1000 tasks) → Still &lt;50ms save</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">WorkflowState persistence to PGlite implemented</criterion>
    <criterion id="2">Checkpoint saved after each layer completion</criterion>
    <criterion id="3"
    >Resume from checkpoint restores full state (tasks, decisions, context)</criterion>
    <criterion id="4">Checkpoint pruning strategy to prevent unbounded growth</criterion>
    <criterion id="5">checkpoint_id generated and stored in state</criterion>
    <criterion id="6">Resume API: executor.resumeFromCheckpoint(checkpointId)</criterion>
    <criterion id="7">Unit tests validating checkpoint/resume correctness</criterion>
    <criterion id="8">Performance: Checkpoint save &lt;50ms</criterion>
    <criterion id="9">Storage: Checkpoint size &lt;100KB for typical workflows</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>{{docs_artifacts}}</docs>
    <code>{{code_artifacts}}</code>
    <dependencies>{{dependencies_artifacts}}</dependencies>
  </artifacts>

  <constraints>{{constraints}}</constraints>
  <interfaces>{{interfaces}}</interfaces>
  <tests>
    <standards>{{test_standards}}</standards>
    <locations>{{test_locations}}</locations>
    <ideas>{{test_ideas}}</ideas>
  </tests>
</story-context>
